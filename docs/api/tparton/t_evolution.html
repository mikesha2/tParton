<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>tparton.t_evolution API documentation</title>
<meta name="description" content="Direct integration method for transversity PDF evolution (Hirai method) …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>tparton.t_evolution</code></h1>
</header>
<section id="section-intro">
<p>Direct integration method for transversity PDF evolution (Hirai method)</p>
<p>This module implements the Hirai et al. method for evolving transversity parton
distribution functions by directly solving the DGLAP integro-differential equation.</p>
<p>The evolution is performed by:
1. Discretizing the momentum fraction x and energy scale Q² into grids
2. Using Euler method for Q² evolution steps
3. Using Simpson's rule for integration over x</p>
<p>This method provides direct control over discretization but can be computationally
expensive for fine grids. It is more suitable when precise control over numerical
parameters is needed.</p>
<h2 id="key-functions">Key Functions</h2>
<p>evolve : Main function to evolve a transversity PDF
splitting : Compute the transversity splitting functions
alp2pi : Compute the strong coupling α_s(Q²)/(2π)</p>
<h2 id="theoretical-background">Theoretical Background</h2>
<p>Solves the DGLAP equation:</p>
<pre><code>∂/∂t Δ_T q^±(x,t) = (α_s(t)/(2π)) Δ_T P_{q^±}(x) ⊗ Δ_T q^±(x,t)
</code></pre>
<p>where t = ln(Q²) and ⊗ denotes Mellin convolution.</p>
<h2 id="references">References</h2>
<ul>
<li>Hirai, M., Kumano, S., &amp; Miyama, M. (1998). Comput. Phys. Commun. 111, 150-166</li>
<li>Sha, C.M. &amp; Ma, B. (2024). arXiv:2409.00221</li>
</ul>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="tparton.t_evolution.alp2pi"><code class="name flex">
<span>def <span class="ident">alp2pi</span></span>(<span>t: float, lnlam: float, order: int, beta0: float, beta1: float) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def alp2pi(t: float, lnlam: float, order: int, beta0: float, beta1: float) -&gt; float:
    &#34;&#34;&#34;Compute α_s(Q²)/(2π) using the analytical approximation.
    
    Implements Eq. (4) from the paper, normalized by 2π.
    This normalization is convenient for the DGLAP evolution equation.
    &#34;&#34;&#34;
    dlnq2 = t - lnlam
    alpha = 4 * pi / beta0 / dlnq2
    alpha_factor = 1 if order == 1 else (1 - beta1 * np.log(dlnq2) / beta0**2 / dlnq2)
    alpha_factor /= (2 * pi)
    return alpha_factor * alpha</code></pre>
</details>
<div class="desc"><p>Compute α_s(Q²)/(2π) using the analytical approximation.</p>
<p>Implements Eq. (4) from the paper, normalized by 2π.
This normalization is convenient for the DGLAP evolution equation.</p></div>
</dd>
<dt id="tparton.t_evolution.evolve"><code class="name flex">
<span>def <span class="ident">evolve</span></span>(<span>pdf: numpy.ndarray,<br>Q0_2: float = 0.16,<br>Q2: float = 5.0,<br>l_QCD: float = 0.25,<br>n_f: int = 5,<br>CG: float = 3,<br>n_t: int = 100,<br>n_z: int = 500,<br>morp: str = 'plus',<br>order: int = 2,<br>logScale: bool = False,<br>verbose: bool = False,<br>Q0_2_a: float = 8315.178393760001,<br>a0: float = 0.009390141642421825,<br>alpha_num: bool = True) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evolve(
    pdf: np.ndarray,
    Q0_2: float = 0.16,
    Q2: float = 5.0,
    l_QCD: float = 0.25,
    n_f: int = 5,
    CG: float = 3,
    n_t: int = 100,
    n_z: int = 500,
    morp: str = &#39;plus&#39;,
    order: int = 2,
    logScale: bool = False,
    verbose: bool = False,
    Q0_2_a: float = 91.1876 ** 2,
    a0: float = 0.118 / 4 / np.pi,
    alpha_num: bool = True
) -&gt; np.ndarray:
    &#34;&#34;&#34;Evolve transversity PDF using the direct integration method (Hirai).
    
    This is the main function for PDF evolution using direct numerical integration
    of the DGLAP equation. More robust for peaked PDFs but slower than Mellin method.
    
    This method:
    1. Discretizes t = ln(Q²) into n_t Euler steps
    2. At each step, computes convolution integral (Eq. 19) using Simpson&#39;s rule
    3. Updates PDF using forward Euler method (Eq. 1)
    
    Parameters
    ----------
    pdf : ndarray
        Input PDF as x*f(x). Can be 1D array (values at x evenly
        spaced on [0, 1]) or 2D array ([[x0, x0*f(x0)], [x1, x1*f(x1)], ...]).
    Q0_2 : float, optional
        Initial energy scale squared in GeV² (default: 0.16).
    Q2 : float, optional
        Final energy scale squared in GeV² (default: 5.0).
    l_QCD : float, optional
        QCD scale parameter Λ in GeV (default: 0.25).
        Only used if alpha_num=False.
    n_f : int, optional
        Number of active quark flavors (default: 5).
    CG : float, optional
        Number of colors, NC (default: 3).
    n_t : int, optional
        Number of Euler time steps (default: 100).
        More steps = better accuracy but slower.
    n_z : int, optional
        Number of z points for convolution integrals (default: 500).
        More points = better accuracy but slower.
    morp : str, optional
        Distribution type (default: &#39;plus&#39;). Options are &#39;plus&#39;
        (ΔT q⁺ = ΔT u + ΔT d) or &#39;minus&#39; (ΔT q⁻ = ΔT u - ΔT d).
    order : int, optional
        Perturbative order (default: 2). Use 1 for LO or 2 for NLO.
    logScale : bool, optional
        Use logarithmic spacing for z points (default: False).
        Recommended for peaked PDFs.
    verbose : bool, optional
        Print progress (time step count) if True (default: False).
    Q0_2_a : float, optional
        Reference scale Q₀² where αs is known, in GeV² (default: 91.1876²).
        Only used if alpha_num=True.
    a0 : float, optional
        Reference coupling αs(Q0_2_a)/(4π) (default: 0.118/(4π)).
        Only used if alpha_num=True.
    alpha_num : bool, optional
        Use numerical ODE evolution for αs if True (default: True).
        If False, uses analytical approximation.
    
    Returns
    -------
    ndarray
        Evolved PDF as 2D array [[x, x*f_evolved(x)], ...]. Shape: (n+1, 2)
        where n is the number of input points.
    
    Examples
    --------
    &gt;&gt;&gt; import numpy as np
    &gt;&gt;&gt; from tparton.t_evolution import evolve
    &gt;&gt;&gt; x = np.linspace(0, 1, 100)
    &gt;&gt;&gt; pdf_in = x * (1-x)**3  # x*f(x) format
    &gt;&gt;&gt; pdf_out = evolve(pdf_in, Q0_2=4.0, Q2=100.0, n_t=200, n_z=1000)
    &gt;&gt;&gt; x_out, xf_out = pdf_out[:, 0], pdf_out[:, 1]
    
    See Also
    --------
    m_evolution.evolve : Mellin moment method (Vogelsang)
    integrate : Performs convolution at a single x value
    splitting : Evaluates splitting functions
    
    References
    ----------
    .. [1] Hirai, M., Kumano, S., &amp; Saito, N. (2004). Phys. Rev. D 69, 054021
    .. [2] Sha, C.M. &amp; Ma, B. (2024). arXiv:2409.00221
    &#34;&#34;&#34;
    if pdf.shape[-1] == 1:
        # If only the x*pdf(x) values are supplied, assume a linear spacing from 0 to 1
        xs = np.linspace(0, 1, len(pdf))
    else:
        # Otherwise split the input array
        xs, pdf = pdf[:, 0], pdf[:, 1]

    sign = 1 if morp == &#39;plus&#39; else -1
    lnlam = 2 * np.log(l_QCD)

    # Calculate the color constants
    _, CF, Tf, beta0, beta1 = constants(CG, n_f)

    # Define the (log) starting and ending energy scales squared
    tmin = np.log(Q0_2)
    tmax = np.log(Q2)

    # Define the timepoints between those energy scales at which Eq. (1) will be integrated
    ts = np.linspace(tmin, tmax, n_t)
    
    def _beta_ode(x, a):
        &#34;&#34;&#34;QCD beta-function ODE for running coupling.

        Parameters
        ----------
        x : float
            Log-energy variable (t = ln Q²). Not used explicitly.
        a : float
            Coupling `a = α_s/(4π)` at scale `x`.

        Returns
        -------
        float
            Time derivative da/dt according to LO/NLO beta function.
        &#34;&#34;&#34;
        return -beta0 * a * a - (beta1 * a * a * a if order == 2 else 0)
    ode = _beta_ode

    # SciPy requires that the times be monotonically increasing or decreasing
    less = ts &lt; np.log(Q0_2_a)
    ts_less = ts[less]
    ts_greater =ts[~less]

    # For energies strictly below the reference energy, evolve toward lower t
    alp2pi_num_less = odeint(ode, a0, [np.log(Q0_2_a)] + list(ts_less[::-1]), tfirst=True).flatten() * 2
    alp2pi_num_less = alp2pi_num_less[-1:0:-1]
    # For energies strictly above the reference energy, evolve toward higher t
    alp2pi_num_greater = odeint(ode, a0, [np.log(Q0_2_a)] + list(ts_greater), tfirst=True).flatten() * 2
    # Combine the alpha / 2 pi in increasing order of energy scale
    alp2pi_num_greater = alp2pi_num_greater[1:]
    alp2pi_num = list(alp2pi_num_less) + list(alp2pi_num_greater)
    if alpha_num:
        # Use the numerically evolved alpha_S / 2 pi
        alp2pi_use = alp2pi_num
    else:
        # Use the approximate analytical expression for alpha_S in Eq. (4)
        alp2pi_use = alp2pi(ts, lnlam, order, beta0, beta1)

    # Euler integration of Eq. (1) by a small timestep dt
    dt = (tmax - tmin) / n_t
    res = np.copy(pdf)

    for i, alp in enumerate(alp2pi_use):
        if verbose:
            print(i+1, &#39; of &#39;, len(ts), &#39;time steps&#39;)
        # Perform the convolution at each x using (possibly log-scaled) z integration points
        inc = np.array([
            integrate(
                res,
                index,
                _z_grid(xs[index], n_z, logScale),
                alp,
                order,
                CF,
                sign,
                CG,
                Tf,
                xs,
            )
            for index in range(1, len(xs) - 1)
        ])
        # Ensure that x*pdf(x) = 0 at x = 0 and x = 1
        inc = np.pad(inc, 1)
        res += dt * inc * alp
    return np.stack((xs, res), axis=1)</code></pre>
</details>
<div class="desc"><p>Evolve transversity PDF using the direct integration method (Hirai).</p>
<p>This is the main function for PDF evolution using direct numerical integration
of the DGLAP equation. More robust for peaked PDFs but slower than Mellin method.</p>
<p>This method:
1. Discretizes t = ln(Q²) into n_t Euler steps
2. At each step, computes convolution integral (Eq. 19) using Simpson's rule
3. Updates PDF using forward Euler method (Eq. 1)</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pdf</code></strong> :&ensp;<code>ndarray</code></dt>
<dd>Input PDF as x<em>f(x). Can be 1D array (values at x evenly
spaced on [0, 1]) or 2D array ([[x0, x0</em>f(x0)], [x1, x1*f(x1)], &hellip;]).</dd>
<dt><strong><code>Q0_2</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Initial energy scale squared in GeV² (default: 0.16).</dd>
<dt><strong><code>Q2</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Final energy scale squared in GeV² (default: 5.0).</dd>
<dt><strong><code>l_QCD</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>QCD scale parameter Λ in GeV (default: 0.25).
Only used if alpha_num=False.</dd>
<dt><strong><code>n_f</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of active quark flavors (default: 5).</dd>
<dt><strong><code>CG</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Number of colors, NC (default: 3).</dd>
<dt><strong><code>n_t</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of Euler time steps (default: 100).
More steps = better accuracy but slower.</dd>
<dt><strong><code>n_z</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Number of z points for convolution integrals (default: 500).
More points = better accuracy but slower.</dd>
<dt><strong><code>morp</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Distribution type (default: 'plus'). Options are 'plus'
(ΔT q⁺ = ΔT u + ΔT d) or 'minus' (ΔT q⁻ = ΔT u - ΔT d).</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Perturbative order (default: 2). Use 1 for LO or 2 for NLO.</dd>
<dt><strong><code>logScale</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use logarithmic spacing for z points (default: False).
Recommended for peaked PDFs.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Print progress (time step count) if True (default: False).</dd>
<dt><strong><code>Q0_2_a</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Reference scale Q₀² where αs is known, in GeV² (default: 91.1876²).
Only used if alpha_num=True.</dd>
<dt><strong><code>a0</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Reference coupling αs(Q0_2_a)/(4π) (default: 0.118/(4π)).
Only used if alpha_num=True.</dd>
<dt><strong><code>alpha_num</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Use numerical ODE evolution for αs if True (default: True).
If False, uses analytical approximation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code></dt>
<dd>Evolved PDF as 2D array [[x, x*f_evolved(x)], &hellip;]. Shape: (n+1, 2)
where n is the number of input points.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from tparton.t_evolution import evolve
&gt;&gt;&gt; x = np.linspace(0, 1, 100)
&gt;&gt;&gt; pdf_in = x * (1-x)**3  # x*f(x) format
&gt;&gt;&gt; pdf_out = evolve(pdf_in, Q0_2=4.0, Q2=100.0, n_t=200, n_z=1000)
&gt;&gt;&gt; x_out, xf_out = pdf_out[:, 0], pdf_out[:, 1]
</code></pre>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>m_evolution.evolve</code></dt>
<dd>Mellin moment method (Vogelsang)</dd>
<dt><code><a title="tparton.t_evolution.integrate" href="#tparton.t_evolution.integrate">integrate()</a></code></dt>
<dd>Performs convolution at a single x value</dd>
<dt><code><a title="tparton.t_evolution.splitting" href="#tparton.t_evolution.splitting">splitting()</a></code></dt>
<dd>Evaluates splitting functions</dd>
</dl>
<h2 id="references">References</h2>
<ul>
<li>Hirai, M., Kumano, S., &amp; Saito, N. (2004). Phys. Rev. D 69, 054021</li>
<li>Sha, C.M. &amp; Ma, B. (2025). arXiv:2409.00221</li>
</ul>
</div>
</dd>
<dt id="tparton.t_evolution.integrate"><code class="name flex">
<span>def <span class="ident">integrate</span></span>(<span>pdf: numpy.ndarray,<br>i: int,<br>z: numpy.ndarray,<br>alp: float,<br>order: int,<br>CF: float,<br>sign: int,<br>CG: int,<br>Tf: float,<br>xs: numpy.ndarray) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integrate(pdf: np.ndarray, i: int, z: np.ndarray, alp: float, order: int, 
              CF: float, sign: int, CG: int, Tf: float, xs: np.ndarray) -&gt; float:
    &#34;&#34;&#34;Perform convolution of PDF with splitting function at a given x value.
    
    Implements the Mellin convolution integral from Eq. (19).
    Uses Simpson&#39;s rule for numerical integration. Handles plus distribution
    prescriptions via ln(1-x) terms. Interpolates PDF between grid points
    for smooth convolution.
    &#34;&#34;&#34;

    # Handle the base case of an empty array
    if len(z) == 0:
        return 0
    
    # Evaluate the splitting function at the points z
    p0, p1, p0pf, p1pf, plus0, del0, plus1, del1 = splitting(z, CF, order, sign, CG, Tf)

    # Implement Eq. (19), instead of Eq. (7) for the convolution
    func = ((p0 + (alp * p1 if order == 2 else 0)) * interp(xs[i] / z, xs, pdf)) + \
        (p0pf + (alp * p1pf if order == 2 else 0)) * pdf[i]

    # When handling the plus prescription, there is a common factor of ln(1-x) when integrating Eq. (10)
    lno = _plus_log_term(xs[i])
    estimate = simpson(func, x=z) + (plus0 * lno + del0) * pdf[i]
    if order == 2:
        estimate += alp * (plus1 * lno + del1) * pdf[i]

    return estimate</code></pre>
</details>
<div class="desc"><p>Perform convolution of PDF with splitting function at a given x value.</p>
<p>Implements the Mellin convolution integral from Eq. (19).
Uses Simpson's rule for numerical integration. Handles plus distribution
prescriptions via ln(1-x) terms. Interpolates PDF between grid points
for smooth convolution.</p></div>
</dd>
<dt id="tparton.t_evolution.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;Command-line interface for direct integration evolution method.
    
    Parses command-line arguments and runs PDF evolution using Hirai&#39;s method.
    This function is called when running `python -m tparton t`.
    
    See Also
    --------
    evolve : Main function for PDF evolution
    &#34;&#34;&#34;
    import argparse, sys
    parser = argparse.ArgumentParser(description=&#39;Evolution of the nonsinglet transversity PDF, according to the DGLAP equation.&#39;)
    parser.add_argument(&#39;type&#39;,action=&#39;store&#39;,type=str,help=&#39;The method you chose&#39;)
    parser.add_argument(&#39;input&#39;, action=&#39;store&#39;, type=str,
                    help=&#39;The CSV file containing (x,x*PDF(x)) pairs on each line. If only a single number on each line, we assume a linear spacing for x between 0 and 1 inclusive&#39;)
    parser.add_argument(&#39;Q0sq&#39;, action=&#39;store&#39;, type=float, help=&#39;The starting energy scale in units of GeV^2&#39;)
    parser.add_argument(&#39;Qsq&#39;, action=&#39;store&#39;, type=float, help=&#39;The ending energy scale in units of GeV^2&#39;)
    parser.add_argument(&#39;--morp&#39;,  action=&#39;store&#39;, nargs=&#39;?&#39;, type=str, default=&#39;plus&#39;, help=&#39;The plus vs minus type PDF (default \&#39;plus\&#39;)&#39;)
    parser.add_argument(&#39;-o&#39;, action=&#39;store&#39;, nargs=&#39;?&#39;, type=str, default=&#39;out.dat&#39;, help=&#39;Output file for the PDF, stored as (x,x*PDF(x)) pairs.&#39;)
    parser.add_argument(&#39;-l&#39;, metavar=&#39;l_QCD&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=float, default=0.25, help=&#39;The QCD scale parameter (default 0.25 GeV^2). Only used when --alpha_num is False.&#39;)
    parser.add_argument(&#39;--nf&#39;, metavar=&#39;n_f&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=int, default=5, help=&#39;The number of flavors (default 5)&#39;)
    parser.add_argument(&#39;--nc&#39;, metavar=&#39;n_c&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=int, default=3, help=&#39;The number of colors (default 3)&#39;)
    parser.add_argument(&#39;--order&#39;, metavar=&#39;order&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=int, default=2, help=&#39;1: leading order, 2: NLO DGLAP (default 2)&#39;)
    parser.add_argument(&#39;--nt&#39;, metavar=&#39;n_t&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=int, default=100, help=&#39;Number of steps to numerically integrate the DGLAP equations (default 100)&#39;)
    parser.add_argument(&#39;--nz&#39;, metavar=&#39;n_z&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=int, default=1000, help=&#39;Number of steps for numerical integration (default 1000)&#39;)
    parser.add_argument(&#39;--logScale&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=bool, default=True, help=&#39;True if integration should be done on a log scale (default True)&#39;)
    parser.add_argument(&#39;--delim&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=str, default=&#39; &#39;, help=&#39;Delimiter for data file (default \&#39; \&#39;). If given without an argument, then the delimiter is whitespace (i.e. Mathematica output.)&#39;)
    parser.add_argument(&#39;--alpha_num&#39;, metavar=&#39;alpha_num&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=bool, default=True, help=&#39;Set to use the numerical solution for the strong coupling constant, numerically evolved at LO or NLO depending on the --order parameter.&#39;)
    parser.add_argument(&#39;--Q0sqalpha&#39;, metavar=&#39;Q0sqalpha&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=float, default=91.1876**2, help=&#39;The reference energy squared at which the strong coupling constant is known. Default is the squared Z boson mass. Use in conjunction with --a0. Only used when --alpha_num is True.&#39;)
    parser.add_argument(&#39;--a0&#39;, metavar=&#39;a0&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=float, default=0.118 / 4 / np.pi, help=&#39;The reference value of the strong coupling constant a = alpha / (4 pi) at the corresponding reference energy --Q0sqalpha. Default is 0.118 / (4 pi), at energy Q0sqalpha = Z boson mass squared. Only used when --alpha_num is True.&#39;)
    parser.add_argument(&#39;-v&#39;, nargs=&#39;?&#39;, action=&#39;store&#39;, type=bool, default=False, help=&#39;Verbose output (default False)&#39;)


    args = parser.parse_args()
    f = args.input
    if args.delim is None:
        pdf = np.genfromtxt(f)
        args.delim = &#39; &#39;
    else:
        pdf = np.genfromtxt(f, delimiter=args.delim)
    Q0sq = args.Q0sq
    Qsq = args.Qsq
    morp = args.morp
    l = args.l
    nf = args.nf
    nc = args.nc
    order = args.order
    nt = args.nt
    nz = args.nz
    logScale = args.logScale
    alpha_num = args.alpha_num
    Q0sqalpha = args.Q0sqalpha
    a0 = args.a0
    verbose = args.v

    res = evolve(pdf,
        Q0_2=Q0sq,
        Q2=Qsq,
        l_QCD=l,
        n_f=nf,
        CG=nc,
        n_t=nt,
        n_z=nz,
        morp=morp,
        order=order,
        logScale=logScale,
        verbose=verbose,
        alpha_num=alpha_num,
        Q0_2_a=Q0sqalpha,
        a0=a0
    )

    np.savetxt(args.o, res.T, delimiter=args.delim)
    if verbose:
        print(res)</code></pre>
</details>
<div class="desc"><p>Command-line interface for direct integration evolution method.</p>
<p>Parses command-line arguments and runs PDF evolution using Hirai's method.
This function is called when running <code>python -m tparton t</code>.</p>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code><a title="tparton.t_evolution.evolve" href="#tparton.t_evolution.evolve">evolve()</a></code></dt>
<dd>Main function for PDF evolution</dd>
</dl></div>
</dd>
<dt id="tparton.t_evolution.splitting"><code class="name flex">
<span>def <span class="ident">splitting</span></span>(<span>z: numpy.ndarray, CF: float, order: int, sign: int, CG: int, Tf: float)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def splitting(z: np.ndarray, CF: float, order: int, sign: int, CG: int, Tf: float):
    &#34;&#34;&#34;Compute transversity splitting functions at given momentum fraction.
    
    Evaluates ΔT P_qq(z) including both LO and NLO contributions.
    Handles plus distributions and delta function contributions separately.
    
    Returns:
        tuple: (p0, p1, p0pf, p1pf, plus0, del0, plus1, del1) where:
        
            - p0, p1: Regular function parts (LO and NLO)
            - p0pf, p1pf: Plus function coefficients  
            - plus0, del0: LO plus and delta function contributions
            - plus1, del1: NLO plus and delta function contributions
    
    Note:
        Implements Eqs. (9), (11), and (12) from the paper. Uses Spence function
        from scipy.special. Regularizes singularities at z=1 with small epsilon (1e-100).
    
    See Also:
        integrate: Uses splitting functions for PDF convolution
    &#34;&#34;&#34;

    # p0 and p0pf correspond to the first term in Eq. (9) containing a plus function prescription
    p0 = CF * 2 * z / (1 - z+1e-100)
    p0pf = -CF * 2 / (1 - z+1e-100)

    # Define z1 and z2 for vectorization of further computations below
    z1 = 1 / (1 + z)
    z2 = z / (1 + z)
    dln1 = np.log(z1)
    dln2 = np.log(z2)
    # The SciPy convention for the Spence function (aka the dilogarithm) differs from that of Hirai, as discussed in Eq. (16)
    s2 = -spence(z2) + spence(z1) - (dln1 ** 2 - dln2 ** 2) * 0.5

    # 1-z
    omz = 1 - z
    #######################################################################################################
    # Non-plus function, non-delta function contributions to the splitting function
    #######################################################################################################
    # First, we evaluate the plus function contributions
    if order == 2:
        p1 = _nlo_regular_terms(z, omz, s2, CF, CG, Tf, sign)
    else:
        p1 = 0
    
    #######################################################################################################
    # Plus function, f(x) g(x)_+ in Eq. (10), contributions to the splitting function
    #######################################################################################################
    # Enforcing the plus prescriptions for the relevant terms in Eq. (12)
    # The plus prescription in line 0 of Eq. (12) results in 0, so it is ignored
    # Line 2 plus prescription in Eq. (12)
    p1pf = _nlo_plus_terms(omz, CF, CG, Tf)

    # Necessary to avoid numerical singularities
    p0[-1] = 0
    p0pf[-1] = 0
    if order == 2:
        p1[-1] = 0
        p1pf[-1] = 0

    # The LO plus and delta function contributions to the integrals
    plus0 = CF * 2
    del0 = CF * 3 / 2

    #######################################################################################################
    # Plus function, -f(1) g(x)_+ in Eq. (10), and delta function contributions to the splitting function
    #######################################################################################################
    if order == 2:
        plus1, del1 = _nlo_plus_delta_constants(CF, CG, Tf)
    else:
        plus1, del1 = 0, 0

    return p0, p1, p0pf, p1pf, plus0, del0, plus1, del1</code></pre>
</details>
<div class="desc"><p>Compute transversity splitting functions at given momentum fraction.</p>
<p>Evaluates ΔT P_qq(z) including both LO and NLO contributions.
Handles plus distributions and delta function contributions separately.</p>
<p>Returns:
tuple: (p0, p1, p0pf, p1pf, plus0, del0, plus1, del1) where:</p>
<pre><code>    - p0, p1: Regular function parts (LO and NLO)
    - p0pf, p1pf: Plus function coefficients  
    - plus0, del0: LO plus and delta function contributions
    - plus1, del1: NLO plus and delta function contributions
</code></pre>
<p>Note:
Implements Eqs. (9), (11), and (12) from the paper. Uses Spence function
from scipy.special. Regularizes singularities at z=1 with small epsilon (1e-100).</p>
<p>See Also:
integrate: Uses splitting functions for PDF convolution</p></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#key-functions">Key Functions</a></li>
<li><a href="#theoretical-background">Theoretical Background</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="tparton" href="index.html">tparton</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="tparton.t_evolution.alp2pi" href="#tparton.t_evolution.alp2pi">alp2pi</a></code></li>
<li><code><a title="tparton.t_evolution.evolve" href="#tparton.t_evolution.evolve">evolve</a></code></li>
<li><code><a title="tparton.t_evolution.integrate" href="#tparton.t_evolution.integrate">integrate</a></code></li>
<li><code><a title="tparton.t_evolution.main" href="#tparton.t_evolution.main">main</a></code></li>
<li><code><a title="tparton.t_evolution.splitting" href="#tparton.t_evolution.splitting">splitting</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
